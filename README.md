# muke_14
Go+Python双语言混合开发
Go+Python双语言混合开发
👇👇👇👇👇👇👇👇点击图片跳转下载地址👇👇👇👇👇👇👇
### 第1章 【阶段一：Go语言基础】1~13章内容 

#### 【阶段一】我们通过python与go的对比式讲解，系统掌握go语法，比如某个知识点在go语言中是如何的，同时在python中又如何使用？两者之间使用上有什么区别？通过对比学习的方式，一来帮助大家快速掌握go语言不墨迹，同时也能加深对python的认识，学习效率事半功倍，为后面的实战进阶夯实基础。【第一章：讲解go语言的特点，介...
1-1 Go+Python双语言混合开发-课程导学 (11:35)

1-2 课程资源获取方式 - 非常重要！！！ (06:07)

1-3 课程中需要用到的开发环境介绍 (03:47)

1-4 windows中安装centos7虚拟机 (19:16)

1-5 xshell的安装和使用 (04:14)

1-6 git的安装和配置 (06:22)

1-7 docker和docker-compose的安装 (10:31)

1-8 mysql和navicat的安装和配置 (10:09)

1-9 python的安装和配置 (08:58)

1-10 python虚拟环境的安装和配置 (09:49)

1-11 pycharm的安装和配置 (11:46)

1-12 windows下安装go和goland的配置 - 很重要！！ (24:47)

1-13 linux下go开发环境搭建 (04:55)

1-14 windows下安装nodejs开发环境 (04:38)

1-15 linxu下安装和配置nodejs开发环境 (04:32)

1-16 代码提示神器 - kite的安装和配置 (07:19)

1-17 go语言介绍 (14:51)

1-18 go的hello world-1 (24:40)

1-19 变量的定义 (18:09)

1-20 匿名变量是什么？ (07:21)

1-21 go语言中的常量是什么？ (15:16)

1-22 常量的iota有什么用？ (21:28)

1-23 变量的作用域也有很多细节你可能没有在意 (17:44)


### 第2章 计算机组成原理快速扫盲

#### 本章节快速讲解静态语言学习过程中最基础的计算机原理，包括各种进制以及ascii码表
2-1 为什么我们要学习计算机组成原理 (11:11)

2-2 二进制、八进制和十六进制 (18:28)

2-3 ascii码表是什么？ (25:44)


### 第3章 基本数据类型、运算符和表达式

#### 本章节我们将全面的了解go语言的整数类型，浮点数类型以及这些基本类型的转换，我们将理解到go语言中的strconv包以及各种转换函数的使用，我们也将通过对比python和go的数据类型来加深两种语言之间的区别
3-1 go语言提供了哪些整数类型？ (24:44)

3-2 float类型和其它数据类型 (16:25)

3-3 go语言最基本的数据类型转换 (16:05)

3-4 strconv的parse类函数将字符串转换为其他类型 (23:41)

3-5 python的基本数据类型转换 (08:04)

3-6 go语言运算符 (18:20)


### 第4章 python的海象运算符和变量注解

#### 本章节我们将介绍python中的新特性- 海象运算符，也会讲解python中的类型申明和函数的类型检查等静态语言具备的功能
4-1 python3.8的新特性-海象运算符 (19:11)

4-2 python的变量居然也能申明类型！ (16:01)

4-3 python如何强制检查函数的参数类型 (20:26)


### 第5章 字符串的基本操作

#### 本章节我们会了解到go语言中字符串相关的细节，包括中文字符串的长度问题、转义符、子串查询和统计、以及字符串的格式化输入和输出等常用的字符串相关功能
5-1 为什么len函数获取中文字符串长度有问题？ (13:50)

5-2 什么是转义符？ (08:49)

5-3 子串查询、子串统计、开始和结尾判断 (08:48)

5-4 子串的替换、连接和分割 (14:40)

5-5 格式化的输入和输出 (27:32)


### 第6章 条件语句和循环语句

#### 本章节我们会了解到go语言中的条件语句和循环语句，除了基本的if和for循环以外还理解到中文在for循环中容易出现的问题，goto语句和switch等常用语句的基本使用，我们也会理解到python中为什么没有switch以及如何实现
6-1 if条件控制语句 (09:47)

6-2 go语言的for循环 (22:00)

6-3 go语言的for range用法 (12:54)

6-4 goto语句能帮我们完成什么功能？ (12:32)

6-5 switch语句能让代码可读性更高 (21:37)

6-6 python中如何实现switch的效果？ (08:12)


### 第7章 最常用的复杂数据类型 - map、数组、 切片

#### 本章节主要讲解go语言中最常用的复杂类型：map、数组、切片， 通过本章节的学习我们不只是会使用go语言的这些基本类型还将了解到python和go语言在这些类型上的差异。比如go语言中切片的实现原理等
7-1 数组的多种初始化方式 (24:36)

7-2 使用for range对数组元素求和 (07:08)

7-3 go语言中的数组是值类型 - 很重要！ (14:39)

7-4 go语言的slice是什么？ (26:21)

7-5 slice切片的的基本操作 (21:20)

7-6 go和python的切片的区别 (06:46)

7-7 slice使用的时候你有没有遇到过这些奇怪的现象？ (10:51)

7-8 slice的底层存储原理-1 (23:00)

7-9 slice的底层存储原理-2 (20:25)

7-10 当append函数遇到make会产生的坑 (11:16)

7-11 map的定义和基本操作 (25:27)


### 第8章 go语言的利器- 指针

#### 本章节我们将会介绍go语言区别于其他语言的利器-指针，除了指针的基本使用以外，还包括make函数和new函数的区别以及new函数的使用过程、nil和python中的none的区别等
8-1 什么是指针 (35:35)

8-2 go的指针和c语言的指针有什么区别？ (05:03)

8-3 make函数和new函数 (11:56)

8-4 图解new函数的执行过程 (10:27)

8-5 go语言中的nil和python中的None有什么区别？ (08:13)


### 第9章 go语言的函数

#### go语言中的函数是静态语言中的一大亮点，基本上满足了python使用者的灵活性。例如：不定长参数、一等公民特性。本章节中我们还会介绍go语言函数中的defer机制以及panic机制和recover的异常处理等。通过对比python的args、kwargs以及go语言的参数也能加深我们对python的理解...
9-1 函数的各种定义 (17:59)

9-2 通过省略号设置参数个数不定长 (10:00)

9-3 go语言中的函数是一等公民 (33:20)

9-4 python中的finally的执行顺序你真的弄懂了吗？ (20:11)

9-5 defer的作用和多个defer的执行顺序 (22:12)

9-6 defer机制你忽略了很多细节 (21:53)

9-7 python是如何处理代码错误和异常的？ (25:22)

9-8 panic和recover的坑 (33:06)


### 第10章 go语言的结构体

#### go语言的结构体是go语言中完成面向对象特征的最重要类型，对于struct的学习和理解有助于我们理解go语言的设计理念，本章节我们会详细的介绍struct的各个细节，包括定义、组合以及结构体标签等
10-1 type的5种应用场景 (13:22)

10-2 python中的class封装性和namedtuple (20:23)

10-3 结构体的定义以及大小写对结构的影响 (18:50)

10-4 结构体的实例化和new函数 (35:59)

10-5 结构体如何绑定方法？ (21:03)

10-6 通过内嵌结构体实现继承的效果 (20:37)

10-7 结构体标签的作用是什么？ (24:47)


### 第11章 go语言的接口

#### go语言的接口设计理念和python的鸭子类型设计理念是一致的，所以学习完本章节你将对python和go对于面向对象的理解有一个新的理解。我们也会对比讲解go语言的设计理念和面向对象语言的区别以及go是如何通过接口达到面向对象的各个主要特性...
11-1 python中的鸭子类型就是go的接口设计理念 (33:31)

11-2 go语言中的接口是一种类型 (12:20)

11-3 为什么说接口是一种抽象类型？ (26:44)

11-4 接口也支持继承 (09:00)

11-5 go的error是一个接口 (07:29)

11-6 空接口的应用场景 (11:53)

11-7 接口的类型断言 (16:53)

11-8 通过接口协议去理解sort的本质 (22:07)


### 第12章 包管理和编码规范

#### go语言的包管理经历过两个重要的阶段，本章节我们将会了解到静态语言是如何进行包管理以及和python的包管理有什么区别，也会着重介绍go编码规范和python的编码规范
12-1 如何使用go modules (15:09)

12-2 go的包和python的包区别 (26:33)

12-3 go的import的各种姿势 (13:58)

12-4 package和init函数的关系 (06:32)

12-5 gopath开发模式和go modules开发模式对比 (21:09)

12-6 go编码规范-1 (21:35)

12-7 go编码规范 - 2 (17:53)

12-8 python编码规范 (04:32)


### 第13章 go并发编程

#### go语言最大的特性是高并发实现非常简单而且并发性很高，本章节我们除了会讲解go语言并发编程中基本概念如：goroutine的基本使用、waitgroup、互斥锁、读写锁、channel以及deadlock出现的场景以外还会介绍另一个非常重要的知识点 - context。我们也会通过和python的协程对比来加深大家对协程的理解。...
13-1 go的goroutine (27:05)

13-2 go的协程和python协程对比 (18:30)

13-3 使用waitgroup控制协程退出 (09:15)

13-4 使用互斥锁同步协程 (19:55)

13-5 使用RWMutex锁同步协程 (15:01)

13-6 通过channel进行goroutine间的通信 (19:57)

13-7 通过for range遍历channel和close关闭channel (10:47)

13-8 双向和单向的channel (14:01)

13-9 使用channel容易出现deadlock的原因 (16:38)

13-10 go中select的应用场景 (18:20)

13-11 context的应用场景 (27:02)

13-12 通过context控制超时 (09:36)


### 第14章 【阶段二：多语言通信基础 - grpc】14~17章内容

#### rpc是微服务开发的起点也很重要，本阶段我们会从0开始讲解rpc是如何开发出来的，然后通过rpc再过渡到grpc，课程会讲解xml-rpc、json-grpc、zero-rpc以及对这些rpc框架做一个分析和一个rpc框架应该如何封装才能达到我们的要求，是一个非常有亮点的阶段，同学们会明白：一个rpc框架应该要解决哪些问题？我们为什么要使用grpc...
14-1 什么是rpc？rpc开发的挑战是什么？-1 (19:49)

14-2 什么是rpc？rpc开发的挑战是什么？- 2 (16:48)

14-3 使用httpserver实现rpc (23:57)

14-4 rpc的开发要素分析 (09:38)

14-5 基于xml的rpc库 (12:20)

14-6 基于json的rpc技术 (27:23)

14-7 基于zeromq的rpc框架 (36:07)


### 第15章 go的rpc体验

#### 本章节中我们会采用和python不一样的方法了解go语言中的rpc开发体验，通过本章节我们将会体验到python和go语言的rpc调用，本章节我们会一步步基于go提供的基础rpc功能开始逐步封装达到grpc的使用效果，本章节是一个非常重要的章节，理解到本章节以后我们上手grpc会很快...
15-1 go快速体验rpc开发 (24:49)

15-2 替换rpc的序列化协议为json (20:07)

15-3 替换rpc的传输协议为http (09:33)

15-4 进一步改造rpc调用的代码-1 (25:22)

15-5 进一步改造rpc调用的代码-2 (14:10)


### 第16章 grpc快速入门

#### 本章节是grpc的快速入门章节，我们除了体验到python和go下的grpc基本使用以外，还会体验到go和python的grpc互相调用，通过本章节学习我们将体验到protobuf的基本定义、grpc的流模式使用
16-1 什么是grpc和protobuf (14:56)

16-2 python下体验protobuf (22:13)

16-3 python体验grpc开发 (24:59)

16-4 python下生产的grpc文件import路径有问题的探讨 (09:09)

16-5 go下grpc快速体验 - 1 (17:41)

16-6 go下grpc快速体验-2 (18:12)

16-7 go和python互相调用 (14:03)

16-8 grpc的流模式的定义 (21:14)

16-9 grpc的单向流，双向流代码实现 (24:41)


### 第17章 protobuf和grpc进阶

#### 前面的章节中我们已经入门了grpc的基本使用，本章节是一个非常重要的进阶过程，本章节的学习将为后续的微服务打下坚实的基础，本章节介绍了大量的protobuf和grpc进阶知识，如：protobuf的各种类型、grpc的metadata、拦截器、验证器、错误处理以及超时机制等等...
17-1 protobuf的基本类型和默认值，python操作的坑 (15:41)

17-2 option go_package的作用 (06:40)

17-3 当proto文件不同步的时候容易出现的问题 (12:28)

17-4 proto文件中引入其他的proto文件 (10:20)

17-5 嵌套的message对象 (12:02)

17-6 protobuf中的enum枚举类型 (07:14)

17-7 map类型 (05:11)

17-8 使用protobuf内置的timestamp类型 (06:44)

17-9 grpc配合asyncio使用 (23:58)

17-10 grpc的metadata机制-go (21:35)

17-11 python操作metada (10:05)

17-12 grpc拦截器 - go (21:18)

17-13 python实现grpc的拦截器 (11:56)

17-14 通过拦截器和metadata实现grpc的auth认证 (17:50)

17-15 grpc的验证器 (32:11)

17-16 grpc中的错误处理 (25:31)

17-17 grpc的超时机制 (07:10)


### 第18章 【阶段三：需求分析、架构设计、orm和web框架基础】18~22章内容

#### 该阶段主要目标：1. 详细的架构演进设计， 单体应用到微服务架构演进过程中要解决的问题？为什么需要微服务架构设计？go和python在微服务设计中分别承担的作用？ 2. 学习 orm和web框架重要组件，我们会选择python作为和数据库最近的底层业务层，一方面python非常适合做业务接口开发，同时python的orm使用会非常的简...
18-1 如何启动电商系统和后台管理系统 (05:01)

18-2 后台管理系统需求 (05:57)

18-3 电商系统需求分析 (06:31)


### 第19章 架构设计

#### 本章节我们将理解到从单体应用到微服务架构设计的整个过程，以及微服务设计过程中需要解决的各个问题，比如服务注册和发现、配置中心、链路追踪等等大量的细节
19-1 单体应用如何部署？ (10:58)

19-2 单体应用开发痛点 (15:55)

19-3 单体应用的架构演变 (18:07)

19-4 服务拆分变动 (08:57)

19-5 微服务的基本拆分 (09:44)

19-6 分层微服务架构 (11:16)

19-7 微服务需要解决的问题 - 重要！！ (21:02)


### 第20章 yapi的安装和配置

#### 前后端分离开发的最大痛点是： 1. 接口管理麻烦 2. 前端等到后端的mock数据 3. 后端测试需要引入postman等测试工具，本章节我们介绍前后端开发过程中的利器：yapi，通过yapi的使用我们能解决这些所有的问题使得前后端开发完全独立...
20-1 前后端分离的系统开发演变过程 (09:47)

20-2 接口文档管理之痛 (07:46)

20-3 yapi的安装和配置 (14:31)

20-4 yapi基本功能使用 (16:31)

20-5 接口的导入和导出 (11:03)


### 第21章 python的orm-peewee

#### 本章节我们将会快速入门python下的流行orm-peewee，本章节主要解决python下的数据库访问，除了基本的crud基本操作以外，还包括多表查询、反向查询以及最后的如何避免n+1查询问题
21-1 peewee的安装和入门-1 (22:36)

21-2 peewee的安装和入门 - 2 (22:20)

21-3 数据的更新和删除 (15:46)

21-4 多条插入、 or查询 (25:43)

21-5 模糊查询、字典展示、排序、limit和去重 (17:35)

21-6 聚合函数、执行原生的sql语句 (12:52)

21-7 多表查询和反向查询 (25:39)

21-8 避免n加1查询问题 (05:34)


### 第22章 go的web框架-gin

#### 本章节我们将会快速的体验到go语言下最流行的web框架之一-gin，我们除了讲解gin的基本功能以外，还会讲解gin中的一些难懂的点-中间件的原理解析。本章节的主要内容包括：gin的路由、表单验证、错误中文翻译、优雅退出等大量的细节...
22-1 gin的helloworld体验 (12:51)

22-2 使用New和Default初始化路由器的区别 (06:54)

22-3 gin的路由分组 (09:25)

22-4 获取url中的变量 (20:46)

22-5 获取get和post表单信息 (16:46)

22-6 gin返回protobuf (18:36)

22-7 登录的表单验证 (18:28)

22-8 注册表单的验证 (12:25)

22-9 表单验证错误翻译成中文 (18:04)

22-10 表单中文翻译的json格式化细节 (09:12)

22-11 自定义gin中间件 (17:26)

22-12 通过abort终止中间件后续逻辑的执行 (12:26)

22-13 gin的中间件原理源码分析 (10:22)

22-14 gin返回html (25:00)

22-15 加载多个html文件 (14:37)

22-16 static静态文件的处理 (05:38)

22-17 gin的优雅退出 (14:36)


### 第23章 【第四阶段：第一个微服务 - 用户服务】23~25章内容

#### 在本阶段我们将开始使用上阶段设计的微服务模式进行电商项目的第一个微服务 - 用户服务，我们会完成用户相关的接口， 用户登录、用户注册、用户列表等大量和用户相关的接口，该阶段完成以后我们不止能对外提供http接口供电商系统和后台管理系统调用，在python服务中完成对go提供grpc接口。该阶段还集成了实际生产环境中...
23-1 新建虚拟环境和项目 (07:28)

23-2 user表结构设计和生成 (27:11)

23-3 md5信息摘要 (14:29)

23-4 md5盐值加密解决用户密码安全问题 (18:05)

23-5 proto接口定义和生成 (21:25)

23-6 用户列表接口 (19:53)

23-7 启动grpc服务 (11:00)

23-8 日志库选型 - loguru (17:46)

23-9 优雅退出server (12:13)

23-10 通过argparse解析传递进入的参数 (08:46)

23-11 通过id和mobile查询用户是否存在 (11:25)

23-12 新建用户接口 (15:23)

23-13 更新用户 (06:07)


### 第24章 web层开发-gin基础项目架构

#### 本章节我们需要改造gin为基本的微服务web层架构服务，在本章节中我们我们除了需要解决基本的项目结构设计以外，还需要解决日志、grpc集成、配置文件管理等基础服务的完善。
24-1 新建项目和目录结构构建 (05:41)

24-2 go高性能日志库 - zap使用 (14:40)

24-3 zap的文件输出 (08:27)

24-4 集成zap和理由初始到gin的启动过程 - 1 (14:23)

24-5 集成zap和理由初始到gin的启动过程-2 (14:54)

24-6 gin调用grpc服务-1 (22:59)

24-7 gin调用grpc服务-2 (21:56)

24-8 配置文件 - viper (24:09)

24-9 viper的配置环境开发环境和生产环境隔离 (20:02)

24-10 viper集成到gin的web服务中 (16:03)


### 第25章 web层开发-用户接口开发

#### 本章节我们除了上一个章节的基础功能如日志、配置文件、优雅退出以外我们还会涉及到更多的知识点： 用户登录、用户注册、短信发送、表单验证、自定义mobile验证、json web token的校验机制、图片验证码以及跨域问题等大量的开发细，通过本章节的学习我们将能够体验到第一个完整的微服务web层的基础结构和功能开发。...
25-1 表单验证的初始化 (26:51)

25-2 自定义mobile验证器 (14:10)

25-3 登录逻辑完善 (18:05)

25-4 session机制在微服务下的问题 (09:01)

25-5 json web token的认证机制 (11:16)

25-6 集成jwt到gin中 (21:02)

25-7 给url添加登录权限验证 (15:07)

25-8 如何解决前后端的跨域问题 (23:30)

25-9 获取图片验证码 (23:41)

25-10 阿里云发送短信 (22:53)

25-11 redis保存验证码 (22:46)

25-12 用户注册接口 (21:40)


### 第26章 【阶段五：服务注册、服务发现、负载均衡、配置中心】26~29章内容

#### 该阶段将解决微服务中最基础也是最重要的问题： 服务注册和发现、配置中心和负载均衡。我们将选择主流的微服务注册组件并将其集成到微服务中，分别集成到gin和python的grpc服务中，解决大量的ip地址和端口的配置问题，服务的健康检查， 大量的微服务配置，还能够发布和发现最新的配置，解决不用重启就能够解决配置的更...
26-1 什么是服务注册和发现以及技术选型 (18:52)

26-2 consul的安装和配置 (17:13)

26-3 服务注册和注销 (19:31)

26-4 服务注册的健康检查 (12:28)

26-5 配置grpc的健康检查 (15:30)

26-6 第三方库实现服务注册 (24:28)

26-7 go集成consul (19:48)


### 第27章 服务集成注册中心

#### 本章节我们将前面开发的service层和gin开发的web层服务集成到consul的服务发现体系中
27-1 srv服务集成consul (23:16)

27-2 gin集成consul (20:52)

27-3 将用户的grpc连接配置到全局共用 (11:30)


### 第28章 负载均衡

#### 本章节我们需要解决微服务中一个非常重要的问题-负载均衡，本章节首先会解决多个服务下的端口动态分配的问题，然后解决负载均衡策略和常用的负载均衡算法，最后讲负载均衡和注册中心集成进来并完成grpc下的负载均衡调用...
28-1 动态获取可用端口 (16:00)

28-2 什么是负载均衡，负载均衡的策略有哪些？ (23:28)

28-3 常用负载均衡算法 (09:21)

28-4 grpc从consul中同步服务信息并进行负载均衡-1 (18:50)

28-5 grpc从consul中同步服务信息并进行负载均衡-2 (09:34)

28-6 gin集成grpc的负载均衡 (06:40)


### 第29章 配置中心

#### 微服务管理除了管理服务实例以外，大量的微服务下的配置也需要一个统一的配置中心来解决，我们将会选择主流的nacos来完成配置的统一管理，以及如何解决在生产环境以及开发环境下的隔离。
29-1 为什么需要配置中心 (14:30)

29-2 配置中心选型-apollo vs nacos (07:36)

29-3 nacos的安装 (05:29)

29-4 nacos的组、配置集、命名空间 (14:30)

29-5 python操作nacos配置 (15:47)

29-6 service层集成nacos (11:52)

29-7 go操作nacos (15:17)

29-8 gin集成nacos (25:46)


### 第30章 【阶段六：电商系统中商品、图片、库存、订单和购物车服务、分布式锁】30~38章

#### 该整个课程中的比重是非常重要的，该阶段除了完成电商各大模块服务的基本接口以外，还解决了微服务中的图片文件的oss存储，通过前端直传的方式解决了将文件上传到阿里云的传输问题，解决了通过分布式锁完成库存的扣减问题，此外还实现了基于乐观锁和redis的分布式锁如何完成库存的扣减问题。通过本阶段的学习以后，我们除...
30-1 需求分析_ (03:55)

30-2 商品分类的表机构设计 (05:24)

30-3 物理删除还是逻辑删除 (22:38)

30-4 其余表结构定义和数据导入 (12:21)

30-5 定义proto文件 (12:17)

30-6 商品服务器的启动 (14:15)

30-7 商品列表页服务接口-1 (19:34)

30-8 商品列表页服务接口-2 (14:36)

30-9 测试商品列表页 (14:16)

30-10 批量获取商品信息 (08:15)

30-11 获取商品的详情和删除商品 (09:51)

30-12 新建商品接口 (21:26)

30-13 更新商品接口 (03:13)

30-14 商品分类列表页-1 (14:36)

30-15 商品分类列表页-2 (13:54)

30-16 商品分类的其他接口 (09:59)

30-17 轮播图相关功能 (06:23)

30-18 品牌相关接口 (06:30)

30-19 品牌分类相关接口 (12:40)


### 第31章 商品服务-web等

#### 本章节我们会使用上一节课中完成的底层微服务接口，在web层我们会完成客户端的调用和底层接口的转换，在本章节中我们除了完成底层的接口调用以外，还需要解决gin的优雅退出、yapi的接口调试，在本章中我们也会提供一个python脚本用于同步python和go的proto以及源码的生成。...
31-1 快速将用户的web服务转换成商品的web服务 (21:08)

31-2 商品的列表页接口-1 (18:28)

31-3 商品的列表页接口-2 (14:20)

31-4 如何设计一个符合go风格的注册中心接口 (23:01)

31-5 gin的退出后的服务注销 (06:00)

31-6 用户的web服务服务注册和优雅退出 (05:39)

31-7 新建商品 (21:37)

31-8 获取商品详情 (09:35)

31-9 商品删除，更新 (18:08)

31-10 商品分类的接口 (23:43)

31-11 轮播图接口和yapi的快速测试 (18:49)

31-12 品牌和品牌分类接口 （proto同步脚本） (16:23)

31-13 品牌分类接口 (13:29)


### 第32章 阿里云的oss服务

#### 微服务下我们无法使用简单的文件上传功能，我们需要使用独立的图片服务，本章节我们除了要使用阿里云上传图片以外，还需要解决阿里云下的oss直传问题，对于直传后的回调问题我们需要通过内网穿透技术来调试。
32-1 为什么要使用阿里云oss (07:58)

32-2 oss的基本概念介绍 (10:55)

32-3 使用代码控制文件上传 (19:02)

32-4 前端直传oss的流程 (15:51)

32-5 gin集成前端直传文件 (21:43)

32-6 为什么我们需要内网穿透 (09:45)

32-7 内网穿透技术解决前端直传的回调 (15:15)

32-8 将oss集成到gin微服务中 (16:02)


### 第33章 库存服务

#### 库存服务我们需要独立出来，库存服务的独立会产生出很多新的问题，本章节我们会详细介绍库存服务的重要性、以及库存的扣减问题和数据库事务的细节，并集成库存的设置接口
33-1 库存服务的重要性 (07:43)

33-2 库存服务表结构设计 (10:20)

33-3 proto接口设计 (14:15)

33-4 配置启动库存服务 (11:09)

33-5 设置库存和获取库存详情 (09:09)

33-6 库存的扣减和事务 (14:53)

33-7 库存归还 (05:26)

33-8 测试库存服务接口 (14:11)

33-9 为所有的商品添加库存信息 (04:21)


### 第34章 分布式锁

#### 本章节我们需要解决分布式系统下的一个非常重要的问题，也是面试中经常被问到的问题-分布式锁。分布式锁在微服务中有大量的应用，所以对于分布式锁的细节我们需要理解到而不是简单的会使用，大公司对分布式锁的要求较高，所以本章节我们会讲解到两个重要的实现手段： 1. 基于数据库的乐观锁 2. 基于redis的分布式锁，...
34-1 订单超卖问题是如何产生的？ (24:32)

34-2 什么是分布式锁 (10:59)

34-3 基于mysql的乐观锁机制实现 (23:26)

34-4 redis分布式锁实现的基本原理 (24:54)

34-5 基于setnx确保分布式锁的原子性 (06:51)

34-6 如何解决分布式锁中的重点难题 (21:57)

34-7 py-redis-lock核心源码分析 (14:22)

34-8 集成redis分布式锁到库存服务 (10:11)

34-9 基于redis的分布式锁的优缺点和其他的分布式锁实现方案 (06:40)


### 第35章 订单和购物车服务-service层

#### 本章节我们要解决订单和购物车相关的功能，订单是电商中的重点，也是难点，订单服务会牵扯到大量的其他微服务，包括商品、库存、用户等服务。订单服务的完整性要涉及到分布式事务，在后续的过程中我们会也会针对性的解决分布式事务以及订单超时和库存归还等细节。...
35-1 需求分析 (06:25)

35-2 表结构设计 (12:45)

35-3 proto文件定义 (19:53)

35-4 启动订单服务 (09:36)

35-5 购物车列表、添加商品到购物车接口 (10:58)

35-6 更新购物车、删除购物车接口 (06:43)

35-7 订单的列表页接口 (09:45)

35-8 订单详情页接口 (12:46)

35-9 新建订单 - 访问商品服务 (24:03)

35-10 新建订单 - 访问库存扣减 (10:18)

35-11 新建订单-本地事务确保创建成功 (16:06)

35-12 测试接口 (17:32)


### 第36章 订单和购物车服务-web等

#### 本章节我们需要和前端联调订单和购物车服务接口，在web服务中我们还需要解决另一个重要的问题-支付宝支付，在本章节我们也会通过内网穿透的方式解决支付成功的回调细节。
36-1 快速启动订单服务 (21:31)

36-2 购物车列表页接口 (16:08)

36-3 添加商品到购物车 (16:18)

36-4 更新和删除购物车记录 (20:56)

36-5 订单列表页 (18:03)

36-6 订单详情接口开发和测试 (14:32)

36-7 新建订单接口开发和测试 (11:32)


### 第37章 用户操作服务-service层

#### 用户操作服务主要解决用户在电商系统中的重要行为：收藏商品、留言、收货地址管理等，经过前面的章节学习，后续的这些操作会变得很简单。
37-1 支付宝沙箱环境开发流程 (05:43)

37-2 私钥、公钥的概念以及支付宝如何解决订单的安全性问题 (20:09)

37-3 支付宝的公钥、私钥和回调url配置 (08:29)

37-4 生成支付宝的支付url (13:50)

37-5 gin集成支付宝支付_3 (17:57)

37-6 支付宝回调通知url逻辑接口 (19:15)


### 第38章 用户操作服务-web等

#### 通过底层的接口可以快速完成这些用户行为的接口调试
38-1 需求分析和表结构定义 (08:31)

38-2 proto接口定义 (07:06)

38-3 运行用户操作服务 (10:36)

38-4 handler的代码解读 (08:22)

38-5 web服务启动 (14:06)

38-6 解读handler的代码 (20:04)

38-7 调试收藏、收货地址、留言接口 (10:40)


### 第39章 前后端联调

#### 本章节将前端vue和后端微服务进行联调，通过联调来发现接口开发的问题以及修改这些问题
39-1 启动online-store服务 (11:21)

39-2 首页接口的请求分析 (06:21)

39-3 商品列表页分析 (05:11)

39-4 个人中心、订单相关功能联调 (08:40)

39-5 前端文件直传的源码解析 (05:51)

39-6 用户详情和更新接口 (14:14)

39-7 后台管理系统-商品列表页 (13:37)

39-8 品牌接口联调 (07:33)

39-9 用户信息相关功能联调 (10:47)


### 第40章 【阶段七：分布式系统技术难点 - 分布式事务、幂等性机制】39~44章内容

#### 在本阶段要解决分布式系统中非常重要的几个问题： 分布式事务、幂等性机制，然后继续完善电商系统中的重要细节， 比如库存的超时归还，订单创建过程中的分布式事务，同时介绍重试机制和重试机制，以及超时、重试以及网络问题带来的幂等性问题，这些都是分布式开发中的重要问题以及面试中会被经常问题的问题。【本章：电商...
40-1 为什么订单会有超时机制 (14:09)

40-2 数据库事务的ACID特性 (15:03)

40-3 分布式系统中出现哪些故障会导致数据不一致？ (09:21)


### 第41章 分布式理论基础和常见的分布式事务解决方案

#### 本章节我们除了需要理解分布式理论：CAP理论和BASE理论以外，还需要了解到柔性事务、刚性事务、ACID等基本概念，在分布式系统下了解2pc、3pc、TCC和基于可靠消息的最终一致性事务。此外分布式事务是微服务中必须要解决的问题，也是难点，所以我们会介绍常用的分布式事务解决方案，如：2pc、TCC、基于可靠消息的最终一致性...
41-1 cap理论 (15:25)

41-2 BASE理论 (10:19)

41-3 2pc两阶段提交分布式事务 (11:09)

41-4 TCC分布式事务实现方案 (17:41)

41-5 TCC分布式事务实现方案-2 (17:46)

41-6 基于本地消息的最终一致性方案 (12:36)

41-7 基于可靠消息的最终一致性 (15:35)

41-8 最大努力通知方案 (14:53)


### 第42章 消息队列在微服务中的作用和选型

#### 本章节我们会讲解消息队列的作用是什么？而且对比目前主流的rabbitmq、rocketmq和kafka。通过消息队列的对比。我们需要决定应该选择什么消息队列以及如何为什么要选择rocketmq。
42-1 mq的应用场景.mp4 (16:05)

42-2 mq消息队列技术选型.mp4 (14:32)


### 第43章 rocketmq消息队列入门

#### 本章节我们需要了解rocketmq的重要组件：broker、nameserver、consumer、producer、topic等。在本章节我们需要理解rocketmq中的两个重要功能：延迟消息和事务消息。
43-1 rocketmq的安装和配置.mp4 (15:10)

43-2 rocketmq的基本概念.mp4 (05:26)

43-3 rocketmq的消息类型.mp4 (14:25)

43-4 在linux中搭建python的rocketmq开发环境.mp4 (08:16)

43-5 pycharm在windows下获取linux下的开发体验.mp4 (05:45)

43-6 python发送rocketmq普通消息.mp4 (11:09)

43-7 python消费普通消息.mp4 (07:46)

43-8 python发送延迟消息.mp4 (06:46)

43-9 python发送事务消息 (12:52)


### 第44章 实现基于可靠消息最终一致性的事务解决库存归还

#### 普通的定时任务无法完美解决订单的定时取消功能，我们需要通过rocketmq的延迟消息解决库存的定时归还。同时为了解决订单新建过程中可能出现的各种问题下的库存扣减和归还问题保持数据的一致性。
44-1 开始之前的网络问题 - 重要！！！ (05:58)

44-2 订单新建的过程中如果保证库存数据的最终一致性 (13:58)

44-3 库存扣减在分布式事务中的特殊性 (06:45)

44-4 订单新建前的事务消息准备 (15:18)

44-5 基于回调实现消息的通信 (12:01)

44-6 什么时候应该对事务消息进行确认？ (09:25)

44-7 库存扣减事务的完善 (11:13)

44-8 库存服务监听rocketmq消息 (04:55)

44-9 库存扣减记录下扣减历史 (15:32)

44-10 库存归还的细节处理 (06:50)

44-11 启动所有微服务的注意事项 (11:08)

44-12 测试分布式事务一致性 (10:48)

44-13 订单超时归还的流程分析 (06:43)

44-14 订单新建成功后发送延时消息 (06:24)

44-15 订单超时后的库存归还实现 (11:52)

44-16 测试库存的超时归还 (04:33)


### 第45章 幂等性机制

#### 由于引入了超时和重试机制，这些重试会引起订单重复，数据重复提交等问题，幂等性机制需要确保这些重复的提交只能保存一条数据，幂等性解决的方案较多如：唯一索引，查询、token机制、乐观锁和分布式锁机制等解决数据的重复提交，本章节我们需要对比各种方案并选择合适的方案来解决订单的重复提交。...
45-1 什么是服务雪崩 (09:47)

45-2 超时、重试和幂等性机制 (10:53)

45-3 哪些情况下需要考虑幂等性问题 (08:03)

45-4 go的grpc重试机制 (09:50)

45-5 python下实现重试机制 (06:30)

45-6 常用的幂等性解决方案 (11:54)


### 第46章 【阶段八：微服务的高可用保障 - 链路追踪、熔断、限流、降级】45~48章内容

#### 前面部分我们虽然解决了分布式系统的重要问题以及接口的基本功能开发，但是一个高可用的微服务框架我们还需要解决负载的微服务间的调用链的监控以及超时可能会带来的服务雪崩问题，通过引入链路追踪以及服务的熔断、限流等机制将会让我们的微服务变得更加可控以及可用性增强，在本阶段中我们会引入jaeger来进行链路追踪，使...
46-1 为什么我们需要链路追踪 (11:17)

46-2 链路追踪技术选型 (07:16)

46-3 jaeger的安装和架构介绍 (08:42)


### 第47章 第二章 链路追踪open tracing和jaeger

#### 本章节我们会理解到链路追踪的标准、以及各种链路追踪的技术对比选型。我们除了需要理解到jaeger的架构以外还会理解到链路追踪的各个细节，包括span、spancontenxt、tracer等基本的概念，而且我们将会快速的体验到在go和python下的jaeger的开发体验。...
47-1 python发送单个span (13:11)

47-2 发送多级调用的span消息 (12:22)

47-3 grpc下发送span消息 (11:24)

47-4 grpc下client_interceptor的源码解读 (10:55)

47-5 grpc下server端发送span消息 (05:25)

47-6 grpc下server_interceptor的源码解读 (04:42)

47-7 在grpc的server端添加子链路 (06:51)


### 第48章 gin和python集成jaeger

#### 经过前面章节的学习我们已经明白了opentracing标准和jaeger，经过前面的章节学习，我们会理解到如何将jaeger集成到python和gin中，我们将会更加深刻的理解到grpc的metada机制以及如何集成到grpc中。经过本章节我们将会体验到复杂的链路中如何清晰的展示到jaeger的ui中。...
48-1 go发送简单的span消息 (09:16)

48-2 go下通过grpc发送span消息 (11:09)

48-3 gin中添加拦截器实现jaeger注入 (20:31)

48-4 修改grpc_opentracing源码 (17:18)

48-5 配置订单服务的web层逻辑 (10:00)

48-6 订单服务的service链路追踪实现 (13:43)


### 第49章 熔断、限流 - sentinel

#### 本章节我们首先会对比一下主流的hystrix和sentinel，通过对比我们选择sentinel作为系统的熔断器。微服务由于调用链路的问题，很容易出现服务雪崩这种严重的错误，本章节我们采用目前最流行的sentinel完成服务间调用的熔断和限流。本阶段中会理解到如何熔断，以及如何限流，通过熔断和限流可以确保一个长的链路不至于因为其...
49-1 什么是限流、熔断和降级 (15:15)

49-2 sentinel和hystrix对比 (05:47)

49-3 sentinel的qps限流 (20:04)

49-4 sentinel的预热和冷启动 (19:19)

49-5 sentinel的Throttling配置策略 (05:10)

49-6 sentinel的熔断接口 (09:39)

49-7 sentinel的熔断接口-基于错误数 (11:26)

49-8 sentinel的熔断接口-基于错误率和慢请求 (07:05)

49-9 gin集成sentinel实现限流 (11:09)

49-10 python下集成CircuitBreaker (09:01)

49-11 python下使用ratelitmit进行限流 (04:25)


### 第50章 【阶段九：API网关】49~50章内容

#### 本阶段我们来完成微服务开发的最后一站 - api网关，经过前面的开发我们已经开发出来了大量的微服务，这些微服务如何对外暴露统一的接口，以及如何解决这些服务的统一认证都将在api网关中实现，在本阶段我们会选择高性能的api网关-kong来完成从用户端到微服务端的调用以及接口管理。【本章内容：API网关技术选型和安装配置...
50-1 什么是api网关 (07:25)

50-2 api网关具备的功能有哪些？ (04:53)

50-3 api网关技术选型 (09:21)

50-4 kong的安装 (20:48)


### 第51章 kong的基本功能

#### 在本章节中我们将会体验到nginx和kong的对比，以及对kong进行技术细节理解，中我们将体验到kong的基本功能，包括url动态路由，jwt的认证配置，我们需要了解到如何将consul的服务注册中心集成到kong的体系中。
51-1 kong的8001、800和1337端口号的关系 (08:03)

51-2 基本的路由转发配置 (09:47)

51-3 kong的service、routes、upstream的请求过程 (06:22)

51-4 kong集成consul实现服务发现和负载均衡 (07:05)

51-5 kong配置jwt实现登录校验 (16:11)

51-6 kong配置反爬和ip黑名单 (09:04)


### 第52章 【阶段十：jekins自动化部署】51~51章内容

#### 在课程的最后我们需要通过jekins来完成大量微服务的统一部署，微服务由于服务较多以及组件依赖较多，我们需要通过自动化部署工具来对这些服务进行统一的部署管理。【本章内容：jekins快速入门：本章节我们从jekins的基本功能介绍到jekins的安装配置到最后的jekins的基本功能使用、本章节我们将会理解到kong的基本功能，包括...
52-1 敏捷开发中的持续集成痛点 (15:46)

52-2 安装jenkins和关闭防火墙 (12:47)

52-3 jenkins构建服务器流程 (11:59)

52-4 安装jenkins常用插件 (09:51)

52-5 通过free style构建项目 (15:00)

52-6 将构建服务器上的代码上传到运行服务器 (16:41)

52-7 通过pipeline实现持续集成 (20:23)

52-8 通过jenkinsfile管理构建pipeline脚本 (06:11)

52-9 通过远程和其他工程触发构建 (07:13)

52-10 定时构建和轮询SCM构建 (08:35)

52-11 参数化pipeline构建项目 (05:13)


### 第53章 jekins自动化部署

#### 本章节我们通过jekins的自动化部署完成大量微服务的部署
53-1 有哪些服务器我们需要部署？ (11:32)

53-2 前端代码上传到git并启动 (09:12)

53-3 nginx中部署vuejs (24:50)

53-4 jenkens部署vuejs项目 (24:11)

53-5 通过go build构建go微服务 (23:19)

53-6 发布go项目到远程服务器上 (09:07)

53-7 通过shell脚本启动gin服务 (12:29)

53-8 构建和部署python微服务-1 (16:31)

53-9 构建和部署python微服务-2 (23:12)


[下载地址](https://51xueit.vip "下载地址")
